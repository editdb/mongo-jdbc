// MongoStatement.java

/**
 *      Copyright (C) 2008 10gen Inc.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *   
 *   ------------------------------------------------------------------------
 *   Changed by Nigel Maddocks, May 2013
 */

package com.mongodb.jdbc;

import java.sql.*;
import java.util.*;

import com.mongodb.*;

public class MongoStatement implements Statement {

    MongoConnection _conn;

    final int _type;
    final int _concurrency;
    final int _holdability;

    int _fetchSize = 0;
    int _maxRows = 0;

    MongoResultSet _last;
    Object _lastCreatedId = null;
    String _lastOperation = null;

    MongoStatement( MongoConnection conn , int type, int concurrency, int holdability){
        _conn = conn;
        _type = type;
        _concurrency = concurrency;
        _holdability = holdability;
        
        if ( _type != 0 )
            throw new UnsupportedOperationException( "type not supported yet" );
        if ( _concurrency != 0 )
            throw new UnsupportedOperationException( "concurrency not supported yet" );
        if ( _holdability != 0 )
            throw new UnsupportedOperationException( "holdability not supported yet" );
        
    }

    // --- batch ---
    
    public void addBatch(String sql){
        throw new UnsupportedOperationException( "batch not supported" );
    }
    public void clearBatch(){
        throw new UnsupportedOperationException( "batch not supported" );
    }
    public int[] executeBatch(){
        throw new UnsupportedOperationException( "batch not supported" );
    }
    
    // --- random
    
    public void cancel(){
        throw new RuntimeException( "not supported yet - can be" );
    }
    
    public void close(){
        _conn = null;
    }

    public Connection getConnection(){
        return _conn;
    }

    public boolean isClosed(){
        return _conn == null;
    }

    public boolean isPoolable(){
        return true;
    }

    public void setPoolable(boolean poolable){
        if ( ! poolable )
            throw new RuntimeException( "why don't you want me to be poolable?" );
    }
    
    public void clearWarnings(){
        throw new RuntimeException( "not supported yet - can be" );        
    }

    // --- writes ----
    
    public boolean execute(String sql){
        throw new RuntimeException( "execute not done" );
    }
    public boolean execute(String sql, int autoGeneratedKeys){
        throw new RuntimeException( "execute not done" );
    }
    public boolean execute(String sql, int[] columnIndexes){
        throw new RuntimeException( "execute not done" );
    }
    public boolean execute(String sql, String[] columnNames){
        throw new RuntimeException( "execute not done" );
    }

    public int executeUpdate(String sql)
        throws SQLException {
//nima 	return new Executor( _conn._db , sql ).writeop();
//niam  return new Executor( this , sql ).writeop();
    	_lastCreatedId = null;
    	_lastOperation = null;
    	Executor executor = new Executor( this , sql );
    	int iResult = executor.writeop();
    	_lastCreatedId = executor._lastCreatedId;
    	_lastOperation = executor._lastOperation;
        return iResult;
    }
    public int executeUpdate(String sql, int autoGeneratedKeys){
        throw new RuntimeException( "executeUpdate not done" );
    }
    public int executeUpdate(String sql, int[] columnIndexes){
        throw new RuntimeException( "executeUpdate not done" );
    }
    public int executeUpdate(String sql, String[] columnNames){
        throw new RuntimeException( "executeUpdate not done" );
    }

    public int getUpdateCount(){
        throw new RuntimeException( "getUpdateCount not done" );
    }

    public ResultSet getGeneratedKeys(){
    	ResultSet rs = null;
    	if (_lastCreatedId != null) {
    		rs = new ListToResultSet("_id", Arrays.asList(new Object[]{_lastCreatedId}));
    	} else {
    		rs = new ListToResultSet("_id", Arrays.asList(new Object[]{}));
    	}
    	return rs;
    }

    // ---- reads -----
    
    public ResultSet executeQuery(String sql)
        throws SQLException {
        // TODO
        // handle max rows

//nima  DBCursor cursor = new Executor( _conn._db , sql ).query();
    	_lastOperation = null;
    	Executor executor = new Executor( this , sql );
        DBCursor cursor = executor.query();
        if ( _fetchSize > 0 )
            cursor.batchSize( _fetchSize );
        if ( _maxRows > 0 )
            cursor.limit( _maxRows );
        
        _last = new MongoResultSet( cursor, _conn._NoColumnValue );
        _lastOperation = executor._lastOperation;
        return _last;
    }

    public int getQueryTimeout(){
        throw new RuntimeException( "query timeout not done" );
    }
    public void setQueryTimeout(int seconds){
        throw new RuntimeException( "query timeout not done" );
    }
    
    // ---- fetch modifiers ----


    public int getFetchSize(){
        return _fetchSize;
    }
    public void setFetchSize(int rows){
        _fetchSize = rows;
    }

    public int getMaxRows(){
        return _maxRows;
    }
    public void setMaxRows(int max){
        _maxRows = max;
    }
    
    public int getFetchDirection(){
        throw new RuntimeException( "fetch direction not done yet" );
    }
    public void setFetchDirection(int direction){
        throw new RuntimeException( "fetch direction not done yet" );
    }
        
    public int getMaxFieldSize(){
        throw new RuntimeException( "max field size not supported" );
    }
    public void setMaxFieldSize(int max){
        throw new RuntimeException( "max field size not supported" );
    }
    
    
    public boolean getMoreResults(){
        throw new RuntimeException( "getMoreResults not supported" );
    }
    public boolean getMoreResults(int current){
        throw new RuntimeException( "getMoreResults not supported" );
    }

    public ResultSet getResultSet(){
        return _last;
    }

    // ---- more random -----


    public SQLWarning getWarnings(){
        throw new UnsupportedOperationException( "warning not supported yet" );
    }

    public void setCursorName(String name){
        throw new UnsupportedOperationException( "can't set cursor name" );
    }
    
    public void setEscapeProcessing(boolean enable){
        if ( ! enable )
            throw new RuntimeException( "why do you want to turn escape processing off?" );
    }

    public int getResultSetConcurrency(){
        return _concurrency;
    }
    public int getResultSetHoldability(){
        return _holdability;
    }
    public int getResultSetType(){
        return _type;
    }

    public <T> T unwrap(Class<T> iface) throws SQLException {
    	if (isWrapperFor(iface)) {
    		return (T)this;
    	}
    	return null;
    }

    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return iface.getName().equals(this.getClass().getName());
    }

    //@Override
	public void closeOnCompletion() throws SQLException {
		// TODO Auto-generated method stub
		
	}

	//@Override
	public boolean isCloseOnCompletion() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}
	
	public String getLastOperation() {
		return _lastOperation;
	}
}
