// MongoStatement.java

/**
 *      Copyright (C) 2008 10gen Inc.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *   
 *   ------------------------------------------------------------------------
 *   Changed by Nigel Maddocks, May 2013
 */

package com.mongodb.jdbc;

import java.sql.*;
import java.util.*;

import org.bson.BsonDocument;
import org.bson.Document;
import org.bson.conversions.Bson;

import com.mongodb.*;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.*;
import com.mongodb.client.result.DeleteResult;
import com.mongodb.client.result.InsertManyResult;
import com.mongodb.client.result.InsertOneResult;
import com.mongodb.client.result.UpdateResult;

public class MongoStatement implements Statement {

    MongoConnection _conn;

    final int _type;
    final int _concurrency;
    final int _holdability;

    int _fetchSize = 0;
    int _maxRows = 0;

    MongoResultSet _last;
    Object _lastCreatedId = null;
    String _lastOperation = null;

    MongoStatement( MongoConnection conn , int type, int concurrency, int holdability){
        _conn = conn;
        _type = type;
        _concurrency = concurrency;
        _holdability = holdability;
        
        if ( _type != 0 )
            throw new UnsupportedOperationException( "type not supported yet" );
        if ( _concurrency != 0 )
            throw new UnsupportedOperationException( "concurrency not supported yet" );
        if ( _holdability != 0 )
            throw new UnsupportedOperationException( "holdability not supported yet" );
        
    }

    // --- batch ---
    
    public void addBatch(String sql){
        throw new UnsupportedOperationException( "batch not supported" );
    }
    public void clearBatch(){
        throw new UnsupportedOperationException( "batch not supported" );
    }
    public int[] executeBatch(){
        throw new UnsupportedOperationException( "batch not supported" );
    }
    
    // --- random
    
    public void cancel(){
        throw new RuntimeException( "not supported yet - can be" );
    }
    
    public void close(){
        _conn = null;
    }

    public Connection getConnection(){
        return _conn;
    }

    public boolean isClosed(){
        return _conn == null;
    }

    public boolean isPoolable(){
        return true;
    }

    public void setPoolable(boolean poolable){
        if ( ! poolable )
            throw new RuntimeException( "why don't you want me to be poolable?" );
    }
    
    public void clearWarnings(){
        throw new RuntimeException( "not supported yet - can be" );        
    }

    // --- writes ----
    
    public boolean execute(String sql) throws SQLException {
    	int bResult = executeUpdate(sql);
    	return true;
    }
    
    public boolean execute(String sql, int autoGeneratedKeys){
        throw new RuntimeException( "execute not done" );
    }
    public boolean execute(String sql, int[] columnIndexes){
        throw new RuntimeException( "execute not done" );
    }
    public boolean execute(String sql, String[] columnNames){
        throw new RuntimeException( "execute not done" );
    }

    public int executeUpdate(String sql) throws SQLException {
//nima 	return new Executor( _conn._db , sql ).writeop();
//niam  return new Executor( this , sql ).writeop();
    	_lastCreatedId = null;
    	_lastOperation = null;
    	try {
    		Executor executor = new Executor( this , sql );
	    	int iResult = executor.writeop();
	    	_lastCreatedId = executor._lastCreatedId;
	    	_lastOperation = executor._lastOperation;
	        return iResult;
    	} catch (Exception e) {

    		MongoDatabase database = _conn._client.getDatabase(_conn._db.getName());
    		String collectionName = getCollectionFromJS(sql);
    		if (collectionName == null) {
    			throw new SQLException("Collection name could not be found");
    		}
    		String op = getOperationFromJS(sql);
    		if (op == null) {
    			throw new SQLException("Operation type could not be found");
    		}
    		
    		MongoCollection<Document> collection = database.getCollection(collectionName);
    		String json = getJSONFromJS(sql);
    		Object bdbObjOrList = null;
    		if (json != null && json.trim().length() > 0) {
    			bdbObjOrList = Executor.JSONParse(json);
    		}
    		
    		if (op.equals("insertOne")) {
	    		InsertOneResult result = collection.insertOne(new Document((BasicDBObject)bdbObjOrList));				
				return result.getInsertedId().isNull()?0:1;    			
    		} else
    		
    		if (op.equals("insertMany")) {
    			BasicDBList bdbList = (BasicDBList)bdbObjOrList;
    			List<Document> lstDoc = new ArrayList<>();
    			for (int idx=0; idx < bdbList.size(); idx++) {
    				BasicDBObject listItem = (BasicDBObject) bdbList.get(idx);
    				lstDoc.add(new Document(listItem));
    			}
	    		InsertManyResult result = collection.insertMany(lstDoc);				
				return result.getInsertedIds().size();    			
    		} else
        		
    		if (op.equals("deleteOne") || op.equals("deleteMany")) {
       			bdbObjOrList = Executor.JSONParseAsArray(json);
    			BasicDBList bdbList = (BasicDBList)bdbObjOrList;
    			BasicDBObject pFilter = (BasicDBObject) bdbList.get(0);
    			DeleteOptions pOptions = new DeleteOptions();
    			if (bdbList.size() > 1) {
    				BasicDBObject oOptions = (BasicDBObject) bdbList.get(2);
    				if (oOptions.containsField("collation")) {
    					BasicDBObject bdbCollation = (BasicDBObject)oOptions.get("collation");
    					Document collationDoc = Document.parse(bdbCollation.toJson());
    					Collation collation = collationFromJson(collationDoc).get();
     					pOptions.collation(collation);
    				}
    				if (oOptions.containsField("hint")) {
    					Object oHint = oOptions.get("hint");
    					if (oHint instanceof String) {
    						pOptions.hintString((String) oHint);
    					} else {
    						pOptions.hint((Bson) oHint);
    					}
    				}
    			}
    			
    			if (op.equals("deleteOne")) {
		    		DeleteResult result = collection.deleteOne(pFilter, pOptions);				
					return (int)result.getDeletedCount();   
    			} else {
    				DeleteResult result = collection.deleteMany(pFilter, pOptions);				
					return (int)result.getDeletedCount();   
    			}
    			
    		} else
    			
    		if (op.equals("updateOne") || op.equals("updateMany")) {
       			bdbObjOrList = Executor.JSONParseAsArray(json);
    			BasicDBList bdbList = (BasicDBList)bdbObjOrList;
    			BasicDBObject pFilter = (BasicDBObject) bdbList.get(0);
    			BasicDBObject pUpdate = (BasicDBObject) bdbList.get(1);
    			UpdateOptions pOptions = new UpdateOptions();
    			if (bdbList.size() > 2) {
    				BasicDBObject oOptions = (BasicDBObject) bdbList.get(2);
    				if (oOptions.containsField("upsert")) {
    					pOptions.upsert(oOptions.getBoolean("upsert")); 
    				}
    				if (oOptions.containsField("collation")) {
    					BasicDBObject bdbCollation = (BasicDBObject)oOptions.get("collation");
    					Document collationDoc = Document.parse(bdbCollation.toJson());
    					Collation collation = collationFromJson(collationDoc).get();
     					pOptions.collation(collation);
    				}
    				if (oOptions.containsField("hint")) {
    					Object oHint = oOptions.get("hint");
    					if (oHint instanceof String) {
    						pOptions.hintString((String) oHint);
    					} else {
    						pOptions.hint((Bson) oHint);
    					}
    				}
    				if (oOptions.containsField("arrayFilters")) {
    					BasicDBList lstFilters = (BasicDBList)oOptions.get("arrayFilters");
    					Bson[] arrBson = lstFilters.toArray(new Bson[]{});
    					List<Bson> lstBson = Arrays.asList(arrBson);
    					pOptions.arrayFilters(lstBson);
    				}
    			}
    			if (op.equals("updateOne")) {
		    		UpdateResult result = collection.updateOne(pFilter, pUpdate, pOptions);				
					return (int)result.getModifiedCount();   
    			} else {
		    		UpdateResult result = collection.updateMany(pFilter, pUpdate, pOptions);				
					return (int)result.getModifiedCount();   
    			}
    		} else
    		
    		if (op.equals("drop")) {
    			collection.drop();
    		} else {
    			throw new SQLException("Other than SQL statements, the only Mongo statements allowed are " +
    				"\"insertOne\", \"insertMany\", \"updateOne\", \"updateMany\", \"deleteOne\", \"deleteMany\", \"drop\"");
    		}
    		
    		return 0;
    	}
    }
    public int executeUpdate(String sql, int autoGeneratedKeys){
        throw new RuntimeException( "executeUpdate not done" );
    }
    public int executeUpdate(String sql, int[] columnIndexes){
        throw new RuntimeException( "executeUpdate not done" );
    }
    public int executeUpdate(String sql, String[] columnNames){
        throw new RuntimeException( "executeUpdate not done" );
    }

    public int getUpdateCount(){
        throw new RuntimeException( "getUpdateCount not done" );
    }

    public ResultSet getGeneratedKeys(){
    	ResultSet rs = null;
    	if (_lastCreatedId != null) {
    		rs = new ListToResultSet("_id", Arrays.asList(new Object[]{_lastCreatedId}));
    	} else {
    		rs = new ListToResultSet("_id", Arrays.asList(new Object[]{}));
    	}
    	return rs;
    }

    // ---- reads -----
    
    public ResultSet executeQuery(String sql)
        throws SQLException {
        // TODO
        // handle max rows

//nima  DBCursor cursor = new Executor( _conn._db , sql ).query();
    	_lastOperation = null;
    	Executor executor = new Executor( this , sql );
        DBCursor cursor = executor.query();
        if ( _fetchSize > 0 )
            cursor.batchSize( _fetchSize );
        if ( _maxRows > 0 )
            cursor.limit( _maxRows );
        
        _last = new MongoResultSet( cursor, _conn._NoColumnValue );
        _lastOperation = executor._lastOperation;
        return _last;
    }
    
    public static String getCollectionFromJS(String js) {
    	int idxBracket = js.indexOf("(");
    	if (idxBracket == -1) {
    		return null;
    	}
    	js = js.substring(0, idxBracket);
    	String[] parts = js.split("\\.");
    	if (parts.length == 3) {
    		return parts[1].trim();
    	} else {
    		return null;
    	}
    }
    
    public static String getOperationFromJS(String js) {
    	int idxBracket = js.indexOf("(");
    	if (idxBracket == -1) {
    		return null;
    	}
    	js = js.substring(0, idxBracket);
    	String[] parts = js.split("\\.");
    	if (parts.length == 3) {
    		return parts[2].trim();
    	} else {
    		return null;
    	}
    }
    
    public static String getJSONFromJS(String js) {
    	int idxBracket = js.indexOf("{");
    	int idxSquareBracket = js.indexOf("[");
    	if (idxBracket == -1) {
    		return null;
    	}
    	String cLastBracket = "}";
    	if (idxSquareBracket > -1 && idxSquareBracket < idxBracket) {
    		cLastBracket = "]";
    		idxBracket = idxSquareBracket;
    	}
    	int idxLastBracket = js.lastIndexOf(cLastBracket);
    	if (idxLastBracket == -1) {
    		return null;
    	}
    	
    	String json = js.substring(idxBracket, idxLastBracket+1);
    	return json;
    }

    public int getQueryTimeout(){
        throw new RuntimeException( "query timeout not done" );
    }
    public void setQueryTimeout(int seconds){
        throw new RuntimeException( "query timeout not done" );
    }
    
    // ---- fetch modifiers ----


    public int getFetchSize(){
        return _fetchSize;
    }
    public void setFetchSize(int rows){
        _fetchSize = rows;
    }

    public int getMaxRows(){
        return _maxRows;
    }
    public void setMaxRows(int max){
        _maxRows = max;
    }
    
    public int getFetchDirection(){
        throw new RuntimeException( "fetch direction not done yet" );
    }
    public void setFetchDirection(int direction){
        throw new RuntimeException( "fetch direction not done yet" );
    }
        
    public int getMaxFieldSize(){
        throw new RuntimeException( "max field size not supported" );
    }
    public void setMaxFieldSize(int max){
        throw new RuntimeException( "max field size not supported" );
    }
    
    
    public boolean getMoreResults(){
        throw new RuntimeException( "getMoreResults not supported" );
    }
    public boolean getMoreResults(int current){
        throw new RuntimeException( "getMoreResults not supported" );
    }

    public ResultSet getResultSet(){
        return _last;
    }

    // ---- more random -----


    public SQLWarning getWarnings(){
        throw new UnsupportedOperationException( "warning not supported yet" );
    }

    public void setCursorName(String name){
        throw new UnsupportedOperationException( "can't set cursor name" );
    }
    
    public void setEscapeProcessing(boolean enable){
        if ( ! enable )
            throw new RuntimeException( "why do you want to turn escape processing off?" );
    }

    public int getResultSetConcurrency(){
        return _concurrency;
    }
    public int getResultSetHoldability(){
        return _holdability;
    }
    public int getResultSetType(){
        return _type;
    }

    public <T> T unwrap(Class<T> iface) throws SQLException {
    	if (isWrapperFor(iface)) {
    		return (T)this;
    	}
    	return null;
    }

    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return iface.getName().equals(this.getClass().getName());
    }

    //@Override
	public void closeOnCompletion() throws SQLException {
		// TODO Auto-generated method stub
		
	}

	//@Override
	public boolean isCloseOnCompletion() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}
	
	public String getLastOperation() {
		return _lastOperation;
	}
	
	public static Optional<Collation> collationFromJson(final Document collationDoc) {
		//if (collationString.isEmpty()) {
		if (collationDoc.size() == 0) {
			return Optional.empty();
		}
		Collation.Builder builder = Collation.builder();
		//Document collationDoc = Document.parse(collationString);
		if (collationDoc.containsKey("locale")) {
			builder.locale(collationDoc.getString("locale"));
		}
		if (collationDoc.containsKey("caseLevel")) {
			builder.caseLevel(collationDoc.getBoolean("caseLevel"));
		}
		if (collationDoc.containsKey("caseFirst")) {
			builder.collationCaseFirst(
					CollationCaseFirst.fromString(collationDoc.getString("caseFirst")));
		}
		if (collationDoc.containsKey("strength")) {
			builder.collationStrength(CollationStrength.fromInt(collationDoc.getInteger("strength")));
		}
		if (collationDoc.containsKey("numericOrdering")) {
			builder.numericOrdering(collationDoc.getBoolean("numericOrdering"));
		}
		if (collationDoc.containsKey("alternate")) {
			builder.collationAlternate(
					CollationAlternate.fromString(collationDoc.getString("alternate")));
		}
		if (collationDoc.containsKey("maxVariable")) {
			builder.collationMaxVariable(
					CollationMaxVariable.fromString(collationDoc.getString("maxVariable")));
		}
		if (collationDoc.containsKey("normalization")) {
			builder.normalization(collationDoc.getBoolean("normalization"));
		}
		if (collationDoc.containsKey("backwards")) {
			builder.backwards(collationDoc.getBoolean("backwards"));
		}
		return Optional.of(builder.build());
	}	
}
